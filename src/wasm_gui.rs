extern crate slime_seed_finder;
#[macro_use]
extern crate stdweb;
#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate serde_json;

#[cfg(target_arch = "wasm32")]
use stdweb::js_export;

use slime_seed_finder::*;
use slime_seed_finder::slime::SlimeChunks;
use slime_seed_finder::biome_layers::Area;
use slime_seed_finder::biome_layers::BIOME_COLORS;

#[cfg(target_arch = "wasm32")]
fn main(){
    // Don't start, wait for user to press button
}

#[derive(Deserialize, Debug)]
pub struct Options {
    #[serde(default)]
    chunks: Vec<[i32; 2]>,
    #[serde(default)]
    no_chunks: Vec<[i32; 2]>,
}

js_deserializable!( Options );

#[cfg(target_arch = "wasm32")]
#[js_export]
//pub fn slime_seed_finder(chunks_str: &str, no_chunks_str: &str) -> String {
//    let r = find_seed(chunks_str, no_chunks_str);
pub fn slime_seed_finder(o: Options) -> String {
    console!(log, "Hello from Rust");
    let r = find_seed(o);

    format!("Found {} seeds!\n{:#?}", r.len(), r)
}

#[cfg(target_arch = "wasm32")]
#[js_export]
pub fn extend48(s: &str) -> String {
    let x = match s.parse() {
        Ok(x) => {
            if x < (1u64 << 48) {
                x
            } else {
                let error_string = format!("Input must be lower than 2^48");
                console!(error, &error_string);
                return error_string;
            }
        }
        Err(e) => {
            let error_string = format!("{}", e);
            console!(error, &error_string);
            return error_string;
        }
    };

    let r = Rng::extend_long_48(x);
    let mut s = format!("Found {} seeds!\n", r.len());
    for seed in r {
        let seed = seed as i64;
        s.push_str(&format!("{}\n", seed));
    }

    s
}

#[cfg(target_arch = "wasm32")]
#[js_export]
pub fn count_candidates(o: Options) -> String {
    let c: Vec<_> = o.chunks.into_iter().map(|c| Chunk::new(c[0], c[1])).collect();
    let nc: Vec<_> = o.no_chunks.into_iter().map(|c| Chunk::new(c[0], c[1])).collect();

    if (c.len() == 0) && (nc.len() == 0) {
        return format!("{} * 2^30 candidates", 1 << 18);
    }
    let sc = SlimeChunks::new(&c, 0, &nc, 0);
    let num_cand = sc.num_low_18_candidates() as u32;
    return format!("{} * 2^30 candidates", num_cand);
}

pub fn find_seed(o: Options) -> Vec<u64> {
    let c: Vec<_> = o.chunks.into_iter().map(|c| Chunk::new(c[0], c[1])).collect();
    let nc: Vec<_> = o.no_chunks.into_iter().map(|c| Chunk::new(c[0], c[1])).collect();

    if (c.len() == 0) && (nc.len() == 0) {
        console!(log, "Can't find seed without chunks");
        return vec![];
    } 
    let sc = SlimeChunks::new(&c, 0, &nc, 0);
    let num_cand = sc.num_low_18_candidates() as u32;
    console!(log, format!("Found {} * 2^30 candidates", num_cand));
    console!(log, format!("ETA: about {} seconds", num_cand * 7));
    let seeds = sc.find_seed();

    {
        // Display only seeds that could be generated by java (empty box)
        let java_seeds: Vec<_> = seeds
            .iter()
            .map(|&s| Rng::extend_long_48(s))
            .collect();

        console!(log, format!("Java seeds: \n{:#?}", java_seeds));
    }

    seeds
}

#[cfg(target_arch = "wasm32")]
#[js_export]
pub fn generate_fragment(fx: i32, fy: i32, seed: String) -> Vec<u8> {
    let seed = if let Ok(s) = seed.parse() {
        s
    } else {
        console!(error, format!("{} is not a valid seed", seed));
        return vec![0; 128*128*4];
    };
    // Fragment size: 128x128

    let last_layer = 43;
    let area = Area { x: fx as i64 * 128, z: fy as i64 * 128, w: 128, h: 128 };
    //let map = cubiomes_test::call_layer(last_layer, seed, area);
    let v = biome_layers::generate_image(area, seed);

    v
}

<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>slime_seed_finder playground</title>
        <style>
            body {
                background-color: #eee;
            }
            input {
                font-family: monospace;
            }
            textarea {
                font-family: monospace;
            }
            #demo {
                position:fixed;
                left:0;
                top:0;
                width:100%;
                height:100%;
                z-index:-1;
                image-rendering:pixelated;
            }
            .controlPanel {
                background-color: #FFFFFF80;
            }
        </style>
        <script src="json-stringify-pretty-compact.js"></script>
    </head>
    <body>
        <div class="controlPanel">
            <a href="https://github.com/Badel2/slime_seed_finder">SLIME SEED FINDER</a>
            <strong>Under construction.</strong>
            <button id="randomSeedButton" onClick="setSeed(randomSeed())">RANDOM</button>
            ENTER SEED:
            <input type="text" id="worldSeed" placeholder="Enter world seed">
            <button id="buttonSub2ToThe" onClick="seedPlus2ToThe48(false)">-2^48</button>
            <button id="buttonAdd2ToThe" onClick="seedPlus2ToThe48(true)">+2^48</button>
            <input type="text" id="add2ToTheN" size=2 value="48">
            <input type="text" id="lastLayer" size=3 value="43">
            <button id="layerPrev" onClick="updateWithLayerPlus(-1)">-</button>
            <button id="layerNext" onClick="updateWithLayerPlus(+1)">+</button>
            &lt;- Layer controls
        </div>
        <div>
            <canvas id="demo"></canvas>
            <div class="controlPanel">
                <button onClick="Game.zoomBy(0.8)">ZOOM -</button>
                <button onClick="Game.zoomBy(1.25)">ZOOM +</button>
                <input id="center_x" size=6 value="0">
                <input id="center_z" size=6 value="0">
                <button id="center_button">CENTER</button>
                <input type="range" min="0" max="10" value="10" class="slider" id="gridSize">
                <button onClick="Game.showGrid = !Game.showGrid; Game.dirty = true">TOGGLE GRID</button>
                <select id="minecraftVersion">
                    <option value="1.7">Java 1.7 - 1.12</option>
                    <option value="1.13">Java 1.13</option>
                    <option value="1.14">Java 1.14</option>
                </select>
                <a id="download" download="biome_map.png">
                        <button type="button" onClick="download()">DOWNLOAD MAP</button>
                </a>
            </div>
            <div id="position_info" class="controlPanel"></div>
        </div>

        <div style="clear: both;"></div>
        <script src="common.js"></script>
        <script src="fragment_map.js"></script>
        <script type="text/javascript" src="wasm_gui.js"></script>
        <script>
            // https://codeburst.io/throttling-and-debouncing-in-javascript-646d076d0a44
            function debounced(delay, fn) {
              let timerId;
              return function (...args) {
                if (timerId) {
                  clearTimeout(timerId);
                }
                timerId = setTimeout(() => {
                  fn(...args);
                  timerId = null;
                }, delay);
              }
            }

            function setSeed(seed) {
                let element = document.getElementById("worldSeed");
                if (element.value != seed) {
                    element.value = seed;
                    // Trigger input event, which will run Game.clear()
                    // https://stackoverflow.com/a/35659572
                    let event = new Event('input', {
                        'bubbles': true,
                        'cancelable': true
                    });

                    element.dispatchEvent(event);
                }
            }

            // Download canvas as named image
            // https://stackoverflow.com/a/42546234
            function download() {
                var download = document.getElementById("download");
                var image = document.getElementById("demo")
                    .toDataURL("image/png")
                    .replace("image/png", "image/octet-stream");
                download.setAttribute("href", image);
                download.setAttribute("download","seed_" + document.getElementById("worldSeed").value + ".png");
            }

            let scales17 = [4096, 2048, 2048, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 512, 256, 256, 256, 256, 256, 128, 64, 64, 256, 128, 64, 64, 64, 32, 32, 16, 16, 8, 4, 4, 128, 64, 32, 16, 8, 4, 4, 4, 4, 1];
            let scales113 = [4096, 2048, 2048, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 512, 256, 256, 256, 256, 256, 128, 64, 64, 256, 128, 64, 64, 64, 32, 32, 16, 16, 8, 4, 4, 128, 64, 32, 16, 8, 4, 4, 4, 4, 256, 128, 64, 32, 16, 8, 4, 4, 1];
            let layerScale = 1;
            let minecraft_version = document.getElementById('minecraftVersion').value;
            {
                let scales;
                if (minecraft_version == "1.7") {
                    scales = scales17;
                } else if (minecraft_version == "1.13" || minecraft_version == "1.14") {
                    scales = scales113;
                } else {
                    console.error("Unknown Minecraft version: " + minecraft_version);
                }
                //let i = document.getElementById("lastLayer").value|0;
                let i = 43;
                document.getElementById("lastLayer").value = i;
                if(i >= 0 && i <= 43) {
                    layerScale = scales[i];
                }
                if(i >= 100 && i <= 143) {
                    layerScale = scales[i - 100];
                }
                if(i >= 200 && i <= 243) {
                    layerScale = scales[i - 200];
                }

                map.currentScale = layerScale;
                Game.setActiveLayer(i);
            }
            function randomSeed() {
                // Return a random 17-digit integer as a string
                // TODO: implement real 64-bit number generation?
                // Or try to emulate Random.nextLong()?
                let r = "";
                // 50% of being negative
                if (Math.random() < 0.5) {
                    r += "-";
                }
                for (let i = 0; i < 17; i++) {
                    let d = Math.floor(Math.random() * 10);
                    r += d;
                }
                return r;
            }
            {
                let seed = document.getElementById("worldSeed").value;
                if (seed == "") {
                    setSeed(randomSeed());
                }
            }
            document.getElementById("add2ToTheN").addEventListener("input", function(event) {
                let value = document.getElementById("add2ToTheN").value|0;
                if(value >= 0 && value <= 64) {} else { value = 0; }
                document.getElementById("buttonSub2ToThe").innerHTML = "-2^" + value;
                document.getElementById("buttonAdd2ToThe").innerHTML = "+2^" + value;
            });
            document.getElementById("lastLayer").addEventListener("input", function(event) {
                updateWithLayerPlus(0);
            });
            document.getElementById('minecraftVersion').addEventListener("input", function(event) {
                // Try to be clever about changing the layer
                let old_v = minecraft_version;
                let new_v = document.getElementById('minecraftVersion').value;

                minecraft_version = new_v;
                let lastLayer = document.getElementById("lastLayer").value|0;
                if (old_v == "1.7" && (new_v == "1.13" || new_v == "1.14")) {
                    if (lastLayer == 42) {
                        updateWithLayerPlus(50 - 42);
                    }
                    if (lastLayer == 43) {
                        updateWithLayerPlus(51 - 43);
                    }
                }
                if ((old_v == "1.13" || old_v == "1.14") && new_v == "1.7") {
                    if (lastLayer == 51) {
                        updateWithLayerPlus(43 - 51);
                    }
                    if (lastLayer == 50) {
                        updateWithLayerPlus(42 - 50);
                    }
                    if (lastLayer >= 43 && lastLayer <= 49) {
                        updateWithLayerPlus(42 - lastLayer);
                    }
                }

                Game.clear();
            });
            function updateWithLayerPlus(x) {
                let i = document.getElementById("lastLayer").value|0;
                i += x;
                let minecraft_version = document.getElementById('minecraftVersion').value;
                let scales;
                let num_layers;
                if (minecraft_version == "1.7") {
                    scales = scales17;
                    num_layers = 43;
                } else if (minecraft_version == "1.13" || minecraft_version == "1.14") {
                    scales = scales113;
                    num_layers = 51;
                } else {
                    console.error("Unknown Minecraft version: " + minecraft_version);
                }
                if(i >= 0 && i <= num_layers) {
                    let newScale = scales[i];
                    if(Game.camera) {
                        Game.camera.resolutionChange(newScale / layerScale);
                    }
                    layerScale = newScale;
                    //Game.clear();
                    Game.setActiveLayer(i);
                    document.getElementById("lastLayer").value = i;
                }
                if(i >= 100 && i <= 143) {
                    let newScale = scales[i - 100];
                    if(Game.camera) {
                        Game.camera.resolutionChange(newScale / layerScale);
                    }
                    layerScale = newScale;
                    //Game.clear();
                    Game.setActiveLayer(i);
                    document.getElementById("lastLayer").value = i;
                }
                if(i >= 200 && i <= 243) {
                    let newScale = scales[i - 200];
                    if(Game.camera) {
                        Game.camera.resolutionChange(newScale / layerScale);
                    }
                    layerScale = newScale;
                    //Game.clear();
                    Game.setActiveLayer(i);
                    document.getElementById("lastLayer").value = i;
                }
                map.currentScale = layerScale;
            }
            function seedPlus2ToThe48(add_not_sub) {
                let ws = document.getElementById('worldSeed');
                let n = document.getElementById('add2ToTheN');
                if(ws && n) {
                    /*
                    let seed = ctypes.Int64(ws.value);
                    seed += ctypes.Int64("0x100000000");
                    ws.value = seed.toString();
                    */
                    // Ok, I'll just implement it in Rust
                    return Rust.wasm_gui.then( function( wasmgui ) {
                        let new_value;
                        if (add_not_sub) {
                            new_value = wasmgui.add_2_n(ws.value, n.value|0);
                        } else {
                            new_value = wasmgui.sub_2_n(ws.value, n.value|0);
                        }
                        setSeed(new_value);
                    }, function( err ) {
                        console.error(err);
                    });
                }
            }
            function pregenerateLayers() {
                let i = document.getElementById("lastLayer").value|0;
                if (i != 43) {
                    alert("Please go to layer 43 first");
                    return;
                }
                // Only works well when current layer == 43
                for(let j=0; j<=43; j++) {
                    Game._drawLayer(j);
                }
            }

            // Hacks to make workers return promises
            // https://codeburst.io/promises-for-the-web-worker-9311b7831733
            const resolves = {}
            const rejects = {}
            let globalMsgId = 0

            // Activate calculation in the worker, returning a promise
            function sendMsg(payload, worker){
              const msgId = globalMsgId++
              const msg = {
                id: msgId,
                payload
              }

              return new Promise(function (resolve, reject) {
                // save callbacks for later
                resolves[msgId] = resolve
                rejects[msgId] = reject

                worker.postMessage(msg)
              })
            }

            // Handle incoming calculation result
            function handleMsg(msg) {
              const {id, err, payload} = msg.data

              if (payload) {
                const resolve = resolves[id]
                if (resolve) {
                  resolve(payload)
                }
              } else {
                // error condition
                const reject = rejects[id]
                if (reject) {
                    if (err) {
                      reject(err)
                    } else {
                      reject('Got nothing')
                    }
                }
              }

              // purge used callbacks
              delete resolves[id]
              delete rejects[id]
            }

            // Wrapper class
            function Wrapper() {
                this.maxWorkers = navigator.hardwareConcurrency || 4;
                console.log("Creating " + this.maxWorkers + " workers");
                this.workers = Array(this.maxWorkers);
                for (let i=0; i<this.maxWorkers; i++) {
                    this.workers[i] = new Worker('./worker_b.js');
                    this.workers[i].onmessage = handleMsg;
                }
                this.incr = 0;
            }
            Wrapper.prototype.sendMsg = function(payload) {
                // Pooling strategy: send one message to each worker
                this.incr++;
                if(this.incr >= this.maxWorkers) {
                    this.incr = 0;
                }
                payload.threadId = this.incr;
                return sendMsg(payload, this.workers[this.incr]);
            }

            const work1 = new Wrapper();

            let FRAG_SIZE = 256;
            // Generate fragment
            // This function should return a promise, which is interpreted as
            // a HTML canvas
            function generateFragmentB(layer, fx, fy) {
                if (window.Worker) {
                    let ws = document.getElementById('worldSeed');
                    // Since js doesnt support 64 bit ints, we just pass
                    // the string to the Rust code, it will be parsed there
                    let seed = ws.value;
                    let actualLastLayer = document.getElementById('lastLayer').value|0;
                    let lastLayer = layer;
                    if (lastLayer != actualLastLayer) {
                        return Promise.reject(new Error("Asked to generate layer " + lastLayer + " when last layer is " + actualLastLayer));
                    }
                    let minecraft_version = document.getElementById('minecraftVersion').value;
                    return work1.sendMsg({ version: minecraft_version, fx: fx, fy: fy, seed: seed, FRAG_SIZE: FRAG_SIZE, lastLayer: lastLayer }).then(function(e) {
                        /*
                        console.log("Copying to canvas: " + fx + ", " + fy);
                        */
                        // Create off-screen canvas
                        let c = document.createElement('canvas');
                        c.width = FRAG_SIZE;
                        c.height = FRAG_SIZE;
                        let ctx = c.getContext('2d');
                        // Generate fragment
                        let imageData = ctx.createImageData(FRAG_SIZE, FRAG_SIZE);
                        //imageData.data = rvec; // please
                        for(let i=0; i<FRAG_SIZE*FRAG_SIZE*4; i++) {
                            imageData.data[i] = e.rvec[i];
                        }
                        ctx.putImageData(imageData, 0, 0);
                        return c;
                    });
                } else {
                    return Rust.wasm_gui.then( function( wasmgui ) {
                        let ws = document.getElementById('worldSeed');
                        // Since js doesnt support 64 bit ints, we just pass
                        // the string to the Rust code, it will be parsed there
                        let seed = ws.value;
                        console.log("Seed: " + seed);
                        console.log("Generating fragment: " + fx + ", " + fy);
                        let rvec = wasmgui.generate_fragment(fx, fy, seed, FRAG_SIZE);
                        console.log("Copying to canvas: " + fx + ", " + fy);
                        // Create off-screen canvas
                        let c = document.createElement('canvas');
                        c.width = FRAG_SIZE;
                        c.height = FRAG_SIZE;
                        let ctx = c.getContext('2d');
                        // Generate fragment
                        let imageData = ctx.createImageData(FRAG_SIZE, FRAG_SIZE);
                        //imageData.data = rvec; // please
                        for(let i=0; i<FRAG_SIZE*FRAG_SIZE*4; i++) {
                            imageData.data[i] = rvec[i];
                        }
                        ctx.putImageData(imageData, 0, 0);
                        return c;
                    }, function( err ) {
                        console.error(err);
                    });
                }
            }

            map.generateFragment = generateFragmentB;

            let ws = document.getElementById('worldSeed');
            let oldSeed = ws.value;
            // Only regenerate map if the input has been static for 500ms
            ws.oninput = debounced(500, function() {
                if (ws.value != oldSeed) {
                    // Regenerate map when seed changes
                    Game.clear();
                    oldSeed = ws.value;
                }
            });

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                Game.dirty = true;
            }

            window.addEventListener('resize', resize, false); resize();
            let lastLayer = document.getElementById('lastLayer').value|0;
            startGame(lastLayer);
        </script>
    </body>
</html>
